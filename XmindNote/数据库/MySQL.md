# MySQL

### 01. MySQL基础架构

MySQL 可以分为 Server 层和存储引擎层两部分。

Server 层包括连接器、查询缓存、分析器、优化器、执行器等。

而存储引擎层负责数据的存储和提取。

### 02. 日志系统：SQL更新语句如何执行

 MySQL 里面最重要的两个日志，即物理日志 redo log 和逻辑日志 binlog。

更新流程还涉及两个重要的日志模块：redo log（重做日志）和 binlog（归档日志）

redo log： MySQL 里经常说到的 WAL 技术，WAL 的全称 是 Write-Ahead Logging，它的关键点就是先写日志，不忙的时候再写磁盘。当有一条记录需要更新的额时候，InnoDB引擎会先记录到redo log中，并更新内存，这时更新就算完成。同时InnoDB引擎会在系统比较空闲的时候将这个记录更新到磁盘里面。内容-》小黑板-》账本。 redo log 是 InnoDB 引擎特有的日志，实现 crash-safe 能力。循环写。

binlog： Server 层的日志，逻辑日志，记录语句的原始逻辑。追加写。

### 03. 事务隔离

事务就是要保证**一组数据库操作**，要么全部成功，要么全部失败。

MySQL 是一个支持多引擎的系统。

 事务的特性：ACID（Atomicity、Consistency、Isolation、Durability，即 **原子性、一致性、隔离性、持久性**）。

有多个事务同时执行的时候，就可能出现**脏读（dirty read）、不可重复读 （non-repeatable read）、幻读（phantom read）**的问题。

SQL 标准的事务隔离级别包括：**读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）**。

1. 读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。“读未提交”隔离级别下直接返回记录上的新值，没有视图概念。（**别人改数据的事务尚未提交，我在我的事务中也能读到。** ）

2. 读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。在“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。（**别人改数据的事务已经提交，我在我的事务中才能读到。** ）

3. 可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据 是一致的。在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复 读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。 （**别人改数据的事务已经提交，我在我的事务中也不去读。** 对于RR，你可以这么想，每个事务启动的时候打一个快照，别人改的“我不听我不 听” ）

   事务启动时的视图可以认为是静态的，不受其他事务更新的影响。

4. 串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。“串行 化”隔离级别下直接用加锁的方式来避免并行访问。（**我的事务尚未提交，别人就别想改数据。** ）

Oracle 数据库的默认隔离 级别其实就是“读提交”

### 04. 索引

索引概念：索引的出现其实就是为了**提高数据查询的效率**，就像书的目录一样。

实现索引的方式：

1. 哈希表 

   key-value结构，key值是非递增的，好处是增加速度快。缺点是，做区间查询速度很慢。

   哈希表这种结构适用于只有等值查询的场景。

2. 有序数组

   有序数组在**等值查询**和**范围查询**场景中的性能就都非常优秀。

   更新数据成本比较高。有序数组索引只适用于静态存储引擎(不会再修改的数据).

3. 搜索树

   二叉搜索树,左儿子小于父节点，父节点又小于右儿子。

   搜索时间复杂度是 O(log(N))。保持平衡二叉树,更新的时间复杂度也是 O(log(N))。

   多叉树，每个节点有多个儿子，儿子之间的大小保证从 左到右递增。

   实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上。

   （为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就 不应该使用二叉树，而是要使用“N 叉”树。这里，“N 叉”树中的“N”取决于数据块 的大小。）

在 MySQL 中，索引是在存储引擎层实现的，所以并没有统一的索引标准。 

InnoDB 存储引擎在 MySQL 数据库中使用最为广泛。

**InnoDB 的索引模型**：

在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为**索引组织表**。

InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的。每一个索引在 InnoDB 里面对应一棵 B+ 树。

基于主键索引和普通索引的查询有什么 区别？主键查询方式，则只需要搜索 ID 这棵 B+ 树；普通索引查询方式，则需要先搜索 k 索引 树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表，非主键索引的查询需要多扫描一棵索引树。

**索引维护**：

B+ 树为了维护索引有序性，在插入新值的时候需要做必要的维护。

B+ 树能够很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数。

**自增主键**是指自增列上定义的主键，建表语句定义： NOT NULL PRIMARY KEY AUTO_INCREMENT。

自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插 入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。
而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。

如字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键呢？

> 由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级 索引的叶子节点占用约 20 个字节，而如果用整型做主键，则只要 4 个字节，如果是长整 型（bigint）则是 8 个字节。
> 显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。
> 所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。

适合用业务字段直接做主键的: 

> 1. 只有一个索引；
> 2.  该索引必须是唯一索引.

如何避免长事务对业务的影响？

> 开发端：
>
> 1. 设置 set autocommit=1。MySQL 的 general_log 开起来，然后随便跑一个业务逻辑。
> 2. 去除不必要的只读事务。无效的 select 语句。
> 3. 根据业务本身的预估，通过 SET MAX_EXECUTION_TIME 命 令，来控制每个语句执行的最长时间。
>
> 数据库端：
>
> 1.  监控 information_schema.Innodb_trx 表，设置长事务阈值，超过就报警 / 或者 kill； 
> 2.  Percona 的 pt-kill 这个工具不错，推荐使用； 
> 3.  在业务功能测试阶段要求输出所有的 general_log，分析日志行为提前发现问题；
> 4. 如果使用的是 MySQL 5.6 或者更新版本，把 innodb_undo_tablespaces 设置成 2（或更大的值）。如果真的出现大事务导致回滚段过大，这样设置后清理起来更方 便。

drop主键索引会导致其他索引失效，但drop普通索引不会。 

二级索引重建应该新建索引再做删除，如果有查询用到这个索引，此时索引已被删除，会 导致业务抖动.主键重建不能采用drop这种方式去按操作，因为所有数据都是以主键组织 的，删了主键后，InnoDB会自己找一个主键组织数据，再次添加主键又会重新组织数 据，重建表的次已达二次，我们可以直接Optimiz这个表























