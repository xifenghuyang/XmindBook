# EffectiveJava笔记

## 第一章  引言

几个重要原则

* 清晰性和简洁性最为重要

* 组件(Component) 指任何可重用的软件元素，组件要尽可能小

* 组件之间的依赖性应尽可能降到最小

* 错误应该尽早被检测出来

  http://joshbloch.com/effectivejava.提供完整示例

  

java语言支持四种类型：

* 接口（包括注释）

* 类（包括enum）

* 数组

* 基本类型

  类、接口、构造器、成员以及序列化形式被统称为API元素

  

## 第二章  创建和销毁对象

### 1. 用静态工厂方法代替构造器

### 2. 遇到多个构造器参数时要考虑使用构建器

### 3. 用私有构造器或者枚举类型强化Singleton属性

### 4. 通过私有构造器强化不可实例的能力

### 5. 优先考虑依赖注入来引用资源

### 6. 避免创建不必要的对象

### 7. 消除过期的对象引用

### 8. 避免使用终结方法( finalizer )和清除方法( cleaner )

### 9. try-with-resources 优先于 try-finally

## 第三章 对于所有对象都通用的方法

### 10. 覆盖equals时请遵守通用约定

### 11. 覆盖equals时总要覆盖hashCode

### 12. 始终要覆盖toString

### 13. 谨慎地覆盖clone

### 14. 考虑实现Comparable接口

## 第四章 类和接口

### 15. 使类和成员的可访问性最小化

封装 [信息隐藏]：把API和实现清晰的隔离开，组件之间只通过API通信。
好处：解耦，模块独立开发、测试、优化、使用、理解、修改。并发开发。组件单独优化。降低构建大型系统的风险。

成员（域、方法、嵌套类、嵌套接口）有四种可能的访问级别：

1. 私有的
2. 包级私有
3. 受保护的
4. 共有的

Java9 新增2种隐式访问级别：

1. 模块系统

类实现接口，类中实现接口的方法都必须声明为共有。

共有类的可变实例成员变量不能是共有的。

### 16. 要在共有类而非共有域中使用访问方法

### 17. 使可变性最小化

Java平台类库中包含许多不可变的类(其实例不能被修改的类)：

String、基本类型的包装类、BigInter、BigDecimal

不可变类好处：易于设计、实现、使用。安全

不可变对象可以只有一种状态，即被创建时的状态。

不可变对象本质上是线程安全的，它们不需要同步。，

不可变对象可以被自由地共享。永远不需要进行保护性拷贝。

不可变类的使用：

1. 对于频繁用到的值，提供共有静态final常量
2. 提供一些静态工厂。

不可变对象唯一的缺点是，对于每个不同的值都需要一个单独的对象。

### 18. 复合（组合）由于继承

HashSet的addAll方法是在它的add方法上实现的。

复合：不扩展现有的类，而是在新的类中增加一个私有域，它引用现有类的一个实例。

继承机制会把超类API中的所有缺陷传播到子类中，而复合则允许设计新的API来隐藏这些缺陷。

### 19. 要么设计继承并提供文档说明，要么禁止继承

好的API文档应该描述一个给定的方法做了什么工作，而不是描述它是如何做到的。

通过构造器调用 私有的方法、final方法、和静态方法是安全的，因为这些方法都不能被子类覆盖。

继承设计的类中，如果实现Cloneable、Serrializable接口，无论是clone还是readObject，无论间接还是直接，都不能调用可覆盖的方法。因为clone和readObject方法在行为上非常类似于构造器。

禁止子类化的两种方法：

1. 将类声明为final
2. 把所有构造器变为私有的，或包级私有，并增加一些共有的静态工厂来替代构造器

### 20. 接口优于抽象类

接口是定义mixin（混合类型）的理性选择。表明它提供了某些可供选择的行为。

minxin：它允许任选的功能混合到类型的主要功能中去。

接口允许构造非层次结构的类型框架。

接口使得安全地增强类的功能成为可能。

骨架实现类：抽象类继承接口。为了继承的目的而设计的。

### 21. 为后代设计接口

尽量避免在已有接口上添加新的默认方法。

但是，在创建接口时，用默认方法提供标准的方法实现，可以简化接口实现的任务。

### 22. 接口只用于定义类型

类实现接口，就可以用接口的类型作为类实例引用的类型。

常量接口模式是对接口的不良使用。

导出常量的三种方式：

1. 使用枚举类型
2. 使用不可实例化的工具类
3. 利用静态导入

### 23. 类层次优于标签类

### 24. 静态成员类优于非静态成员类

四种嵌套类，除第1种外，其他均为内部类

1. 静态成员类
2. 非静态成员类
3. 匿名类
4. 局部类

### 25. 限制源文件为单个顶级类

## 第五章 泛型

### 26. 请不要使用原生态类型

定义

泛型类/接口：声明中含有一个或多个类型参数的类或者接口。泛型类和接口统称为泛型。

使用泛型，声明一个参数化的类型，编译器可以在编译期进行类型校验。

泛型信息，会在运行时被擦除。

泛型的优点：

1. 安全性
2. 描述性

Set 原生态类型，脱离泛型系统，不安全。

Set<Object> 参数化类型，可以包含任何对象的类型的集合；

Set<?> 通配符类型，只能包含某种未知对象类型的一个集合；

### 27. 消除非受检的警告

### 28. 列表优于数组

数组是协变的。covariant

泛型是可变的。invariant

泛型通过擦除来实现。只在编译时强化类型信息。

数组是具体化的，在运行时知道和强化元素类型。

数组提供了运行时的类型安全，但是没有编译时的类型安全；

泛型提供了编译时的类型安全，但是没有运行时的类型安全。

数组和泛型不能混合使用。

### 29. 优先考虑泛型

使用泛型比使用需要在客户端代码中进行转换的类型更加安全。

在设计新类型的时候，要确保他们不需要这种转换就可以使用。只要时间允许，就把现有的类型都泛型化。

### 30. 优先考虑泛型方法

声明类型参数的**类型参数列表**，添加在方法的修饰符和返回值之间。

**泛型单例工厂**：编写一个静态工厂方法，重复地给每个必要的类型参数分发对象。

像类型一样，应该确保方法不用转换，就可以使用。

### 31. 利用有限制通配符来提升API的灵活性

为了获得最大限度的灵活性，要在表示生产者或消费者的输入参数上使用通配符类型。

通配符基本原则 PECS: producer--extends <? extends T> , consumer--super <? super T>

Comparable和Comparator都是消费者，使用中：

* Comparable<? super T> 优于Comparable<T> 
* Comparator<? super T> 优于Comparator<T>

### 32. 谨慎并用泛型和可变参数

可变参数：让客户端可以将可变数量的参数传递给方法。

技术实现：当调用一个可变参数方法时，会创建一个数组用来存放可变参数。

所有的泛型和参数类型都是非具体化的，运行时代码信息比编译时少。

将值保存在泛型可变参数数组中是不安全的。

泛型可变参数方法在下列条件下是安全的：

1. 它没有在可变参数数组中保存任何值。
2. 它没有对不被信任的代码开放该数组。

可变参数和范数之间不能很好配合，因为可变参数是构建在顶级数组之上的。

### 33. 优先考虑类型安全的异构容器

将键进行参数化，而不是容器参数化。然后将参数化的键提交给容器来插入或者获取值。用泛型系统来确保值的类型与它的键相符。

注解API广泛利用了有限制的类型令牌。被注解的元素本质上是类型安全的异构容器，容器的键属于注解类型。

集合API说明了泛型的一般用法，限制了每个容器只能有固定数目的类型参数。可以通过将类型参数放在键上而不是容器上来避开这一限制。

## 第六章 枚举和注解

### 34. 用enum代替int常量

Java支持两种特殊用途的**引用类型**：

1. 枚举类型（类）
2. 注解类型（接口）

**枚举类型**：一组固定的常量组成合法值的类型。

传统的类中使用静态常量方式模拟枚举，非常脆弱。因为这种枚举是编译时常量。一旦关联发生变化，就要重新编译。

Java枚举类型是功能十分齐全的类。它的枚举本质上是int值。

特点：

1. 方式：通过共有的静态final域为每个枚举常量导出一个实例。
2. 是final类：没有可访问的构造器。
3. 实例受控：客户端不能创建枚举类型实例，也不能进行扩展。
4. 是单例的泛型化，本质上是单元素的枚举。

将不同的行为与每个枚举常量关联起来：

在枚举类型中声明一个抽象的apply方法，并在特定于常量的类主体中，用具体的方法覆盖每个常量的抽象apply方法。被称作**特定于常量的方法实现**。

枚举类型有一个自动产生的valueOf(String) 方法，它将常量的名字转变为常量本身。因此可以直接使用.values()。

### 35. 用实例域代替序数

### 36. 用EnumSet代替位域

java.util包提供了EnumSet类来有效地表示从单个枚举类型中提取的多个值的多个集合。

### 37. 用EnumMap代替序数索引

最好不要用序数来索引数组，而要使用EnumMap

### 38. 用接口模拟可扩展的枚举

枚举类型不是可扩展的，接口类型是可扩展的。虽然无法编写可扩展的枚举类型，但是可以通过编写接口以及实现该接口的基础枚举类型来对它进行模拟。可以写一个枚举类，实现一个接口。

### 39. 注解优先于命名模式

### 40. 坚持使用Override注解

为了覆盖Object.equals必须定义一个参数为Object类型的equals方法。

在非抽象类中，父类中含有抽象方法，如果没有被覆盖，编译器会报错。

### 41. 用标记接口定义类型

标记接口marker interface：不包含方法声明的接口，标明一个类实现具体某种属性的接口。

1. 标记接口定义的类型是有**被标记类的实例**实现的。标记注解没有定义这样的类型。
2. 标记接口类型的存在，允许在编译时就能捕捉到错误。

Serializable标记接口。标明一个类型是可以序列化的。

如果标记是应用于任何程序元素而不是类或者接口，就**必须使用注解**。

如果标记只应用于类和接口，优先使用**标记接口**。

## 第七章  Lambda和Stream

Java8增加了，函数接口、Lambda、方法引用——使得创建函数对象更容易。

增加了Steam API——为处理数据元素的序列提供类库级支持。

### 42. Lambda优先于匿名类

以往，创建函数对象的主要方式是通过匿名类。满足传统的面向对象设计模式对函数对象的需求。策略模式。

**函数接口**：带有单个抽象方法的接口。允许使用Lambda表达式创建这些接口的实例。类似匿名类的函数。

Lambda限于函数接口，如果想创建抽象类的实例，可以用匿名类来完成。

尽可能不要序列化一个Lambda。

Lambda是表示小函数对象的最佳方式。

### 43. 方法引用优先于Lambda

### 44.  坚持使用标准的函数接口

模板方法：

用一个子类覆盖基本类型方法，来限制其超类的行为。——传统实现

提供一个接受函数对象的静态工厂或者构造器。——替代实现

java.util.function包已经提供了大量标准的函数接口。优先考虑使用这种标准的函数接口。

java.util.function共有43个接口，其中6个基础接口。基础接口作用于对象引用类型，

1. Operator接口：表示结果与参数类型一致的函数。（UnaryOperator、BinaryOperator）
2. Predicate接口：表示含有有一个参数，返回一个boolean的函数。
3. Function接口：表示参数与返回类型不一致的函数。
4. Supplier接口：表示没有参数并且返回一个值的函数。
5. Consumer接口：带有一个参数但不返回任何值的函数。

现有的大多数标准函数接口都只支持基本类型。

必须始终用@FunctionalInterface注解对自己编写的函数接口进行标注。目的

1. 告诉这个类及文档的读者，这个接口是针对Lambda设计的；
2. 这个接口不会进行编译，除非它只是一个抽象方法
3. 避免后续维护人员不小心给该接口添加抽象方法。

### 45. 谨慎使用Stream





































### 

### 