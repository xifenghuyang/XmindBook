# EffectiveJava笔记

## 第一章  引言

几个重要原则

* 清晰性和简洁性最为重要

* 组件(Component) 指任何可重用的软件元素，组件要尽可能小

* 组件之间的依赖性应尽可能降到最小

* 错误应该尽早被检测出来

  http://joshbloch.com/effectivejava.提供完整示例

  

java语言支持四种类型：

* 接口（包括注释）

* 类（包括enum）

* 数组

* 基本类型

  类、接口、构造器、成员以及序列化形式被统称为API元素

  

## 第二章  创建和销毁对象

### 1. 用静态工厂方法代替构造器

### 2. 遇到多个构造器参数时要考虑使用构建器

### 3. 用私有构造器或者枚举类型强化Singleton属性

### 4. 通过私有构造器强化不可实例的能力

### 5. 优先考虑依赖注入来引用资源

### 6. 避免创建不必要的对象

### 7. 消除过期的对象引用

### 8. 避免使用终结方法( finalizer )和清除方法( cleaner )

### 9. try-with-resources 优先于 try-finally

## 第三章 对于所有对象都通用的方法

### 10. 覆盖equals时请遵守通用约定

### 11. 覆盖equals时总要覆盖hashCode

### 12. 始终要覆盖toString

### 13. 谨慎地覆盖clone

### 14. 考虑实现Comparable接口

## 第四章 类和接口

### 15. 使类和成员的可访问性最小化

封装 [信息隐藏]：把API和实现清晰的隔离开，组件之间只通过API通信。
好处：解耦，模块独立开发、测试、优化、使用、理解、修改。并发开发。组件单独优化。降低构建大型系统的风险。

成员（域、方法、嵌套类、嵌套接口）有四种可能的访问级别：

1. 私有的
2. 包级私有
3. 受保护的
4. 共有的

Java9 新增2种隐式访问级别：

1. 模块系统

类实现接口，类中实现接口的方法都必须声明为共有。

共有类的可变实例成员变量不能是共有的。

### 16. 要在共有类而非共有域中使用访问方法

### 17. 使可变性最小化

Java平台类库中包含许多不可变的类(其实例不能被修改的类)：

String、基本类型的包装类、BigInter、BigDecimal

不可变类好处：易于设计、实现、使用。安全

不可变对象可以只有一种状态，即被创建时的状态。

不可变对象本质上是线程安全的，它们不需要同步。，

不可变对象可以被自由地共享。永远不需要进行保护性拷贝。

不可变类的使用：

1. 对于频繁用到的值，提供共有静态final常量
2. 提供一些静态工厂。

不可变对象唯一的缺点是，对于每个不同的值都需要一个单独的对象。

### 18. 复合（组合）由于继承

HashSet的addAll方法是在它的add方法上实现的。

复合：不扩展现有的类，而是在新的类中增加一个私有域，它引用现有类的一个实例。

继承机制会把超类API中的所有缺陷传播到子类中，而复合则允许设计新的API来隐藏这些缺陷。

### 19. 要么设计继承并提供文档说明，要么禁止继承

好的API文档应该描述一个给定的方法做了什么工作，而不是描述它是如何做到的。

通过构造器调用 私有的方法、final方法、和静态方法是安全的，因为这些方法都不能被子类覆盖。

继承设计的类中，如果实现Cloneable、Serrializable接口，无论是clone还是readObject，无论间接还是直接，都不能调用可覆盖的方法。因为clone和readObject方法在行为上非常类似于构造器。

禁止子类化的两种方法：

1. 将类声明为final
2. 把所有构造器变为私有的，或包级私有，并增加一些共有的静态工厂来替代构造器

### 20. 接口优于抽象类

接口是定义mixin（混合类型）的理性选择。表明它提供了某些可供选择的行为。

minxin：它允许任选的功能混合到类型的主要功能中去。

接口允许构造非层次结构的类型框架。

接口使得安全地增强类的功能成为可能。

骨架实现类：抽象类继承接口。为了继承的目的而设计的。

### 21. 为后代设计接口

尽量避免在已有接口上添加新的默认方法。

但是，在创建接口时，用默认方法提供标准的方法实现，可以简化接口实现的任务。

### 22. 接口只用于定义类型

类实现接口，就可以用接口的类型作为类实例引用的类型。

常量接口模式是对接口的不良使用。

导出常量的三种方式：

1. 使用枚举类型
2. 使用不可实例化的工具类
3. 利用静态导入

### 23. 类层次优于标签类

### 24. 静态成员类优于非静态成员类

四种嵌套类，除第1种外，其他均为内部类

1. 静态成员类
2. 非静态成员类
3. 匿名类
4. 局部类

### 25. 限制源文件为单个顶级类

## 第五章 泛型

### 26. 请不要使用原生态类型

定义

泛型类/接口：声明中含有一个或多个类型参数的类或者接口。泛型类和接口统称为泛型。

使用泛型，声明一个参数化的类型，编译器可以在编译期进行类型校验。

泛型信息，会在运行时被擦除。

泛型的优点：

1. 安全性
2. 描述性

Set 原生态类型，脱离泛型系统，不安全。

Set<Object> 参数化类型，可以包含任何对象的类型的集合；

Set<?> 通配符类型，只能包含某种未知对象类型的一个集合；

### 27. 消除非受检的警告

### 28. 列表优于数组

数组是协变的。covariant

泛型是可变的。invariant

泛型通过擦除来实现。只在编译时强化类型信息。

数组是具体化的，在运行时知道和强化元素类型。

数组提供了运行时的类型安全，但是没有编译时的类型安全；

泛型提供了编译时的类型安全，但是没有运行时的类型安全。

数组和泛型不能混合使用。

### 29. 优先考虑泛型

使用泛型比使用需要在客户端代码中进行转换的类型更加安全。

在设计新类型的时候，要确保他们不需要这种转换就可以使用。只要时间允许，就把现有的类型都泛型化。

### 30. 优先考虑泛型方法

声明类型参数的**类型参数列表**，添加在方法的修饰符和返回值之间。

**泛型单例工厂**：编写一个静态工厂方法，重复地给每个必要的类型参数分发对象。

像类型一样，应该确保方法不用转换，就可以使用。

### 31. 利用有限制通配符来提升API的灵活性

为了获得最大限度的灵活性，要在表示生产者或消费者的输入参数上使用通配符类型。

通配符基本原则 PECS: producer--extends <? extends T> , consumer--super <? super T>

Comparable和Comparator都是消费者，使用中：

* Comparable<? super T> 优于Comparable<T> 
* Comparator<? super T> 优于Comparator<T>

### 32. 谨慎并用泛型和可变参数

可变参数：让客户端可以将可变数量的参数传递给方法。

技术实现：当调用一个可变参数方法时，会创建一个数组用来存放可变参数。

所有的泛型和参数类型都是非具体化的，运行时代码信息比编译时少。

将值保存在泛型可变参数数组中是不安全的。

泛型可变参数方法在下列条件下是安全的：

1. 它没有在可变参数数组中保存任何值。
2. 它没有对不被信任的代码开放该数组。

可变参数和范数之间不能很好配合，因为可变参数是构建在顶级数组之上的。

### 33. 优先考虑类型安全的异构容器

将键进行参数化，而不是容器参数化。然后将参数化的键提交给容器来插入或者获取值。用泛型系统来确保值的类型与它的键相符。

注解API广泛利用了有限制的类型令牌。被注解的元素本质上是类型安全的异构容器，容器的键属于注解类型。

集合API说明了泛型的一般用法，限制了每个容器只能有固定数目的类型参数。可以通过将类型参数放在键上而不是容器上来避开这一限制。

## 第六章 枚举和注解

### 34. 用enum代替int常量

Java支持两种特殊用途的**引用类型**：

1. 枚举类型（类）
2. 注解类型（接口）

**枚举类型**：一组固定的常量组成合法值的类型。

传统的类中使用静态常量方式模拟枚举，非常脆弱。因为这种枚举是编译时常量。一旦关联发生变化，就要重新编译。

Java枚举类型是功能十分齐全的类。它的枚举本质上是int值。

特点：

1. 方式：通过共有的静态final域为每个枚举常量导出一个实例。
2. 是final类：没有可访问的构造器。
3. 实例受控：客户端不能创建枚举类型实例，也不能进行扩展。
4. 是单例的泛型化，本质上是单元素的枚举。

将不同的行为与每个枚举常量关联起来：

在枚举类型中声明一个抽象的apply方法，并在特定于常量的类主体中，用具体的方法覆盖每个常量的抽象apply方法。被称作**特定于常量的方法实现**。

枚举类型有一个自动产生的valueOf(String) 方法，它将常量的名字转变为常量本身。因此可以直接使用.values()。

### 35. 用实例域代替序数

### 36. 用EnumSet代替位域

java.util包提供了EnumSet类来有效地表示从单个枚举类型中提取的多个值的多个集合。

### 37. 用EnumMap代替序数索引

最好不要用序数来索引数组，而要使用EnumMap

### 38. 用接口模拟可扩展的枚举

枚举类型不是可扩展的，接口类型是可扩展的。虽然无法编写可扩展的枚举类型，但是可以通过编写接口以及实现该接口的基础枚举类型来对它进行模拟。可以写一个枚举类，实现一个接口。

### 39. 注解优先于命名模式

### 40. 坚持使用Override注解

为了覆盖Object.equals必须定义一个参数为Object类型的equals方法。

在非抽象类中，父类中含有抽象方法，如果没有被覆盖，编译器会报错。

### 41. 用标记接口定义类型

标记接口marker interface：不包含方法声明的接口，标明一个类实现具体某种属性的接口。

1. 标记接口定义的类型是有**被标记类的实例**实现的。标记注解没有定义这样的类型。
2. 标记接口类型的存在，允许在编译时就能捕捉到错误。

Serializable标记接口。标明一个类型是可以序列化的。

如果标记是应用于任何程序元素而不是类或者接口，就**必须使用注解**。

如果标记只应用于类和接口，优先使用**标记接口**。

## 第七章  Lambda和Stream

Java8增加了，函数接口、Lambda、方法引用——使得创建函数对象更容易。

增加了Steam API——为处理数据元素的序列提供类库级支持。

### 42. Lambda优先于匿名类

以往，创建函数对象的主要方式是通过匿名类。满足传统的面向对象设计模式对函数对象的需求。策略模式。

**函数接口**：带有单个抽象方法的接口。允许使用Lambda表达式创建这些接口的实例。类似匿名类的函数。

Lambda限于函数接口，如果想创建抽象类的实例，可以用匿名类来完成。

尽可能不要序列化一个Lambda。

Lambda是表示小函数对象的最佳方式。

### 43. 方法引用优先于Lambda

### 44.  坚持使用标准的函数接口

模板方法：

用一个子类覆盖基本类型方法，来限制其超类的行为。——传统实现

提供一个接受函数对象的静态工厂或者构造器。——替代实现

java.util.function包已经提供了大量标准的函数接口。优先考虑使用这种标准的函数接口。

java.util.function共有43个接口，其中6个基础接口。基础接口作用于对象引用类型，

1. Operator接口：表示结果与参数类型一致的函数。（UnaryOperator、BinaryOperator）
2. Predicate接口：表示含有有一个参数，返回一个boolean的函数。
3. Function接口：表示参数与返回类型不一致的函数。
4. Supplier接口：表示没有参数并且返回一个值的函数。
5. Consumer接口：带有一个参数但不返回任何值的函数。

现有的大多数标准函数接口都只支持基本类型。

必须始终用@FunctionalInterface注解对自己编写的函数接口进行标注。目的

1. 告诉这个类及文档的读者，这个接口是针对Lambda设计的；
2. 这个接口不会进行编译，除非它只是一个抽象方法
3. 避免后续维护人员不小心给该接口添加抽象方法。

### 45. 谨慎使用Stream

### 46. 优先选择Stream中无副作用的函数

Stream并不只是一个API，它是一种基于函数编程的模型。

为了利用速度、并行性，需要采用Stream范性。

Stream范型最重要的是把计算构成一系列变型，每一级结果尽可能靠近上一级结果的纯函数。

**纯函数**:结果只取决于输入的函数 

Stream中forEach操作应该只用于报告Stream计算的结果，而不是执行计算。

Stream的collectors API包含36种方法：

1. 分类器groupingBy、
2. 收集器 toList、toSet、toCollection
3. 收集器 toMap、toConcurrentMap
4. 收集器 joining

### 47. Stream要优先用Collection作为返回类型

### 48. 谨慎使用Stream并行

并行历史

1. 1996年，java发布。通过同步和wait/notify内置了对线程支持。
2. java5 引入 java.util.concurrent类库，提供并行集合、执行者框架。
3. java7 引入fork-join包，处理并行分解的高性能框架。
4. java8 引入Stream，调用parallel方法实现并行处理。

千万不要任意的并行Stream pipeline，如果源头来自Stream.iterator,或者使用了中间操作的limit，那么并行pipeline也不可能提升性能。

分割迭代器spliterator

引用局部性locality of reference

并行Stream不仅可能降低性能，包括活性失败，还可能导致结果出错，以及难以预计的行为。

通常，程序中所有的并行Stream pipeline都是在一个通用的fork-join池中运行的。只要有一个pipeline运行异常，都会损害系统中其他不相关部分的性能。

## 第八章 方法

### 49. 检查参数的有效性

失败原子性

Java7 增加的Object.requireNonNull方法，不必再手工进行null检查。可以指定自己的异常详情。

Java9 增加了检查范围的方法，java.util.Objects. chechFromIndexSize,checkFromToIndex,checkIndex.

非共有方法通常应该使用断言(assertion)来检查它们的参数。断言被声称的条件将会为真。断言失败，抛出AssertionError。

检查构造器参数的有效性非常重要，可以避免构造出来的对象违反了这个类的约束条件。

### 50. 必要时进行保护性拷贝

对于参数类型可以被不可信任方子类化的参数，不要使用clone方法进行保护性拷贝，应该用new创建形式。

编写方法或构造器，如果允许客户提供过的对象进入内部数据结构，需要考虑是否参数保护性拷贝。

同样，内部组件被返回给客户端之前，对它们进行保护性拷贝也是同样道理。

长度非零的数组总是可变的。

只要有可能都应该使用不可变对象作为对象内部的组件。

### 51. 谨慎设计方法签名

避免过长的参数列表三种方法：

1. 把方法拆分成多个方法
2. 创建辅助类
3. 采用Builder模式

对于**参数的类型**，优先使用接口定义而不是类。

对于boolean参数，要优先使用两个元素的枚举类型。

### 52. 慎用重载

覆盖机制（子类、父类之间）是标准规范，而重载（同一个类中同名函数）机制是例外。覆盖不受运行时类型的影响。

### 53. 慎用可变参数

每次调用可变参数方法都会导致一次数组分配和初始化。

### 54. 返回零长度的数组或者集合，而不是null

### 55. 谨慎返回optional

Optional<T>类表示一个不可变容器，可以存放单个非null的T引用，或者什么也没有。不可变集合，最多存放一个元素。

永远不要通过返回Optional的方法返回null。

如果无法返回结果并且当没有返回结果时，客户端必须执行特殊的处理，那么就应该声明该方法返回Optional<T>.

对于注重性能的方法，最好是返回一个null，或者抛出异常。

最好不要讲optional用作返回值以外的其他用途。

### 56. 为所有导出的API元素编写文档注释

在每个**被导出的**类、接口、构造器、方法、域声明之前增加一个文档注释。

方法的注释：描述它和客户端之间的约定。

1. 描述方法做了什么，而不是怎么做的
2. 调用的前提条件
3. 后置条件
4. 副作用

@implSpec注释，描述方法及其子类之间的约定，为继承设计类时。

## 第九章 通用编程

### 57. 将局部变量的作用域最小化

在第一次要使用的地方进行声明。

几乎每个局部变量的声明都应该包含一个初始化表达式。

将局部变量的作用域最小化的方法是，使方法小而集中。

### 58. for-each循环优先于传统的for循环

通过完全隐藏迭代器或者索引变量，避免了混乱和出错的可能。

三种情况无法使用for-each循环：

1. 解构过滤。若果需要遍历集合，并**删除选定的元素**，就需要使用显示的迭代器。
2. 转换。如果需要遍历列表或者数组，并**取代它的部分或者全部元素值**。
3. 平行迭代。如果需要并行地遍历多个集合，需要显式地控制迭代器或者索引变量。

### 59. 了解和使用类库

使用标准类库

随机数生成器：ThreadLocalRandom。Fork Join Pool和并行Stream中使用SplittableRandom

应该把时间花在应用程序上，而不是底层的细节上。

java.lang 、 java.util 、java.io 及子包中的内容。

集合框架：Collections Framework、Stream类库

学习使用Google Guava

```xml
<dependency>
    <groupId>com.google.guava</groupId>
    <artifactId>guava</artifactId>
    <version>18.0</version>
</dependency>
```
































### 

### 