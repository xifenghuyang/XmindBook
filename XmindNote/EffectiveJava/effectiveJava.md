# EffectiveJava笔记

[TOC]



## 第一章  引言

几个重要原则

* 清晰性和简洁性最为重要

* 组件(Component) 指任何可重用的软件元素，组件要尽可能小

* 组件之间的依赖性应尽可能降到最小

* 错误应该尽早被检测出来

  http://joshbloch.com/effectivejava.提供完整示例

  

java语言支持四种类型：

* 接口（包括注释）

* 类（包括enum）

* 数组

* 基本类型

  类、接口、构造器、成员以及序列化形式被统称为API元素

  

## 第二章  创建和销毁对象

### 1. 用静态工厂方法代替构造器

### 2. 遇到多个构造器参数时要考虑使用构建器

### 3. 用私有构造器或者枚举类型强化Singleton属性

### 4. 通过私有构造器强化不可实例的能力

### 5. 优先考虑依赖注入来引用资源

### 6. 避免创建不必要的对象

### 7. 消除过期的对象引用

### 8. 避免使用终结方法( finalizer )和清除方法( cleaner )

### 9. try-with-resources 优先于 try-finally

## 第三章 对于所有对象都通用的方法

### 10. 覆盖equals时请遵守通用约定

### 11. 覆盖equals时总要覆盖hashCode

### 12. 始终要覆盖toString

### 13. 谨慎地覆盖clone

### 14. 考虑实现Comparable接口

## 第四章 类和接口

### 15. 使类和成员的可访问性最小化

封装 [信息隐藏]：把API和实现清晰的隔离开，组件之间只通过API通信。
好处：解耦，模块独立开发、测试、优化、使用、理解、修改。并发开发。组件单独优化。降低构建大型系统的风险。

成员（域、方法、嵌套类、嵌套接口）有四种可能的访问级别：

1. 私有的
2. 包级私有
3. 受保护的
4. 共有的

Java9 新增2种隐式访问级别：

1. 模块系统

类实现接口，类中实现接口的方法都必须声明为共有。

共有类的可变实例成员变量不能是共有的。

### 16. 要在共有类而非共有域中使用访问方法

### 17. 使可变性最小化

Java平台类库中包含许多不可变的类(其实例不能被修改的类)：

String、基本类型的包装类、BigInter、BigDecimal

不可变类好处：易于设计、实现、使用。安全

不可变对象可以只有一种状态，即被创建时的状态。

不可变对象本质上是线程安全的，它们不需要同步。，

不可变对象可以被自由地共享。永远不需要进行保护性拷贝。

不可变类的使用：

1. 对于频繁用到的值，提供共有静态final常量
2. 提供一些静态工厂。

不可变对象唯一的缺点是，对于每个不同的值都需要一个单独的对象。

### 18. 复合（组合）由于继承

HashSet的addAll方法是在它的add方法上实现的。

复合：不扩展现有的类，而是在新的类中增加一个私有域，它引用现有类的一个实例。

继承机制会把超类API中的所有缺陷传播到子类中，而复合则允许设计新的API来隐藏这些缺陷。

### 19. 要么设计继承并提供文档说明，要么禁止继承

好的API文档应该描述一个给定的方法做了什么工作，而不是描述它是如何做到的。

通过构造器调用 私有的方法、final方法、和静态方法是安全的，因为这些方法都不能被子类覆盖。

继承设计的类中，如果实现Cloneable、Serrializable接口，无论是clone还是readObject，无论间接还是直接，都不能调用可覆盖的方法。因为clone和readObject方法在行为上非常类似于构造器。

禁止子类化的两种方法：

1. 将类声明为final
2. 把所有构造器变为私有的，或包级私有，并增加一些共有的静态工厂来替代构造器

### 20. 接口优于抽象类

接口是定义mixin（混合类型）的理性选择。表明它提供了某些可供选择的行为。

minxin：它允许任选的功能混合到类型的主要功能中去。

接口允许构造非层次结构的类型框架。

接口使得安全地增强类的功能成为可能。

骨架实现类：抽象类继承接口。为了继承的目的而设计的。

### 21. 为后代设计接口

尽量避免在已有接口上添加新的默认方法。

但是，在创建接口时，用默认方法提供标准的方法实现，可以简化接口实现的任务。

### 22. 接口只用于定义类型

类实现接口，就可以用接口的类型作为类实例引用的类型。

常量接口模式是对接口的不良使用。

导出常量的三种方式：

1. 使用枚举类型
2. 使用不可实例化的工具类
3. 利用静态导入

### 23. 类层次优于标签类

### 24. 静态成员类优于非静态成员类

四种嵌套类，除第1种外，其他均为内部类

1. 静态成员类
2. 非静态成员类
3. 匿名类
4. 局部类

### 25. 限制源文件为单个顶级类

## 第五章 泛型

### 26. 请不要使用原生态类型

定义

泛型类/接口：声明中含有一个或多个类型参数的类或者接口。泛型类和接口统称为泛型。

使用泛型，声明一个参数化的类型，编译器可以在编译期进行类型校验。

泛型信息，会在运行时被擦除。

泛型的优点：

1. 安全性
2. 描述性

Set 原生态类型，脱离泛型系统，不安全。

Set<Object> 参数化类型，可以包含任何对象的类型的集合；

Set<?> 通配符类型，只能包含某种未知对象类型的一个集合；

### 27. 消除非受检的警告

### 28. 列表优于数组

数组是协变的。covariant

泛型是可变的。invariant

泛型通过擦除来实现。只在编译时强化类型信息。

数组是具体化的，在运行时知道和强化元素类型。

数组提供了运行时的类型安全，但是没有编译时的类型安全；

泛型提供了编译时的类型安全，但是没有运行时的类型安全。

数组和泛型不能混合使用。

### 29. 优先考虑泛型

使用泛型比使用需要在客户端代码中进行转换的类型更加安全。

在设计新类型的时候，要确保他们不需要这种转换就可以使用。只要时间允许，就把现有的类型都泛型化。

### 30. 优先考虑泛型方法

声明类型参数的**类型参数列表**，添加在方法的修饰符和返回值之间。

**泛型单例工厂**：编写一个静态工厂方法，重复地给每个必要的类型参数分发对象。

像类型一样，应该确保方法不用转换，就可以使用。

### 31. 利用有限制通配符来提升API的灵活性

为了获得最大限度的灵活性，要在表示生产者或消费者的输入参数上使用通配符类型。

通配符基本原则 PECS: producer--extends <? extends T> , consumer--super <? super T>

Comparable和Comparator都是消费者，使用中：

* Comparable<? super T> 优于Comparable<T> 
* Comparator<? super T> 优于Comparator<T>

### 32. 谨慎并用泛型和可变参数

可变参数：让客户端可以将可变数量的参数传递给方法。

技术实现：当调用一个可变参数方法时，会创建一个数组用来存放可变参数。

所有的泛型和参数类型都是非具体化的，运行时代码信息比编译时少。

将值保存在泛型可变参数数组中是不安全的。

泛型可变参数方法在下列条件下是安全的：

1. 它没有在可变参数数组中保存任何值。
2. 它没有对不被信任的代码开放该数组。

可变参数和范数之间不能很好配合，因为可变参数是构建在顶级数组之上的。

### 33. 优先考虑类型安全的异构容器

将键进行参数化，而不是容器参数化。然后将参数化的键提交给容器来插入或者获取值。用泛型系统来确保值的类型与它的键相符。

注解API广泛利用了有限制的类型令牌。被注解的元素本质上是类型安全的异构容器，容器的键属于注解类型。

集合API说明了泛型的一般用法，限制了每个容器只能有固定数目的类型参数。可以通过将类型参数放在键上而不是容器上来避开这一限制。

## 第六章 枚举和注解

### 34. 用enum代替int常量

Java支持两种特殊用途的**引用类型**：

1. 枚举类型（类）
2. 注解类型（接口）

**枚举类型**：一组固定的常量组成合法值的类型。

传统的类中使用静态常量方式模拟枚举，非常脆弱。因为这种枚举是编译时常量。一旦关联发生变化，就要重新编译。

Java枚举类型是功能十分齐全的类。它的枚举本质上是int值。

特点：

1. 方式：通过共有的静态final域为每个枚举常量导出一个实例。
2. 是final类：没有可访问的构造器。
3. 实例受控：客户端不能创建枚举类型实例，也不能进行扩展。
4. 是单例的泛型化，本质上是单元素的枚举。

将不同的行为与每个枚举常量关联起来：

在枚举类型中声明一个抽象的apply方法，并在特定于常量的类主体中，用具体的方法覆盖每个常量的抽象apply方法。被称作**特定于常量的方法实现**。

枚举类型有一个自动产生的valueOf(String) 方法，它将常量的名字转变为常量本身。因此可以直接使用.values()。

### 35. 用实例域代替序数

### 36. 用EnumSet代替位域

java.util包提供了EnumSet类来有效地表示从单个枚举类型中提取的多个值的多个集合。

### 37. 用EnumMap代替序数索引

最好不要用序数来索引数组，而要使用EnumMap

### 38. 用接口模拟可扩展的枚举

枚举类型不是可扩展的，接口类型是可扩展的。虽然无法编写可扩展的枚举类型，但是可以通过编写接口以及实现该接口的基础枚举类型来对它进行模拟。可以写一个枚举类，实现一个接口。

### 39. 注解优先于命名模式

### 40. 坚持使用Override注解

为了覆盖Object.equals必须定义一个参数为Object类型的equals方法。

在非抽象类中，父类中含有抽象方法，如果没有被覆盖，编译器会报错。

### 41. 用标记接口定义类型

标记接口marker interface：不包含方法声明的接口，标明一个类实现具体某种属性的接口。

1. 标记接口定义的类型是有**被标记类的实例**实现的。标记注解没有定义这样的类型。
2. 标记接口类型的存在，允许在编译时就能捕捉到错误。

Serializable标记接口。标明一个类型是可以序列化的。

如果标记是应用于任何程序元素而不是类或者接口，就**必须使用注解**。

如果标记只应用于类和接口，优先使用**标记接口**。

## 第七章  Lambda和Stream

Java8增加了，函数接口、Lambda、方法引用——使得创建函数对象更容易。

增加了Steam API——为处理数据元素的序列提供类库级支持。

### 42. Lambda优先于匿名类

以往，创建函数对象的主要方式是通过匿名类。满足传统的面向对象设计模式对函数对象的需求。策略模式。

**函数接口**：带有单个抽象方法的接口。允许使用Lambda表达式创建这些接口的实例。类似匿名类的函数。

Lambda限于函数接口，如果想创建抽象类的实例，可以用匿名类来完成。

尽可能不要序列化一个Lambda。

Lambda是表示小函数对象的最佳方式。

### 43. 方法引用优先于Lambda

### 44.  坚持使用标准的函数接口

模板方法：

用一个子类覆盖基本类型方法，来限制其超类的行为。——传统实现

提供一个接受函数对象的静态工厂或者构造器。——替代实现

java.util.function包已经提供了大量标准的函数接口。优先考虑使用这种标准的函数接口。

java.util.function共有43个接口，其中6个基础接口。基础接口作用于对象引用类型，

1. Operator接口：表示结果与参数类型一致的函数。（UnaryOperator、BinaryOperator）
2. Predicate接口：表示含有有一个参数，返回一个boolean的函数。
3. Function接口：表示参数与返回类型不一致的函数。
4. Supplier接口：表示没有参数并且返回一个值的函数。
5. Consumer接口：带有一个参数但不返回任何值的函数。

现有的大多数标准函数接口都只支持基本类型。

必须始终用@FunctionalInterface注解对自己编写的函数接口进行标注。目的

1. 告诉这个类及文档的读者，这个接口是针对Lambda设计的；
2. 这个接口不会进行编译，除非它只是一个抽象方法
3. 避免后续维护人员不小心给该接口添加抽象方法。

### 45. 谨慎使用Stream

### 46. 优先选择Stream中无副作用的函数

Stream并不只是一个API，它是一种基于函数编程的模型。

为了利用速度、并行性，需要采用Stream范性。

Stream范型最重要的是把计算构成一系列变型，每一级结果尽可能靠近上一级结果的纯函数。

**纯函数**:结果只取决于输入的函数 

Stream中forEach操作应该只用于报告Stream计算的结果，而不是执行计算。

Stream的collectors API包含36种方法：

1. 分类器groupingBy、
2. 收集器 toList、toSet、toCollection
3. 收集器 toMap、toConcurrentMap
4. 收集器 joining

### 47. Stream要优先用Collection作为返回类型

### 48. 谨慎使用Stream并行

并行历史

1. 1996年，java发布。通过同步和wait/notify内置了对线程支持。
2. java5 引入 java.util.concurrent类库，提供并行集合、执行者框架。
3. java7 引入fork-join包，处理并行分解的高性能框架。
4. java8 引入Stream，调用parallel方法实现并行处理。

千万不要任意的并行Stream pipeline，如果源头来自Stream.iterator,或者使用了中间操作的limit，那么并行pipeline也不可能提升性能。

分割迭代器spliterator

引用局部性locality of reference

并行Stream不仅可能降低性能，包括活性失败，还可能导致结果出错，以及难以预计的行为。

通常，程序中所有的并行Stream pipeline都是在一个通用的fork-join池中运行的。只要有一个pipeline运行异常，都会损害系统中其他不相关部分的性能。

## 第八章 方法

### 49. 检查参数的有效性

失败原子性

Java7 增加的Object.requireNonNull方法，不必再手工进行null检查。可以指定自己的异常详情。

Java9 增加了检查范围的方法，java.util.Objects. chechFromIndexSize,checkFromToIndex,checkIndex.

非共有方法通常应该使用断言(assertion)来检查它们的参数。断言被声称的条件将会为真。断言失败，抛出AssertionError。

检查构造器参数的有效性非常重要，可以避免构造出来的对象违反了这个类的约束条件。

### 50. 必要时进行保护性拷贝

对于参数类型可以被不可信任方子类化的参数，不要使用clone方法进行保护性拷贝，应该用new创建形式。

编写方法或构造器，如果允许客户提供过的对象进入内部数据结构，需要考虑是否参数保护性拷贝。

同样，内部组件被返回给客户端之前，对它们进行保护性拷贝也是同样道理。

长度非零的数组总是可变的。

只要有可能都应该使用不可变对象作为对象内部的组件。

### 51. 谨慎设计方法签名

避免过长的参数列表三种方法：

1. 把方法拆分成多个方法
2. 创建辅助类
3. 采用Builder模式

对于**参数的类型**，优先使用接口定义而不是类。

对于boolean参数，要优先使用两个元素的枚举类型。

### 52. 慎用重载

覆盖机制（子类、父类之间）是标准规范，而重载（同一个类中同名函数）机制是例外。覆盖不受运行时类型的影响。

### 53. 慎用可变参数

每次调用可变参数方法都会导致一次数组分配和初始化。

### 54. 返回零长度的数组或者集合，而不是null

### 55. 谨慎返回optional

Optional<T>类表示一个不可变容器，可以存放单个非null的T引用，或者什么也没有。不可变集合，最多存放一个元素。

永远不要通过返回Optional的方法返回null。

如果无法返回结果并且当没有返回结果时，客户端必须执行特殊的处理，那么就应该声明该方法返回Optional<T>.

对于注重性能的方法，最好是返回一个null，或者抛出异常。

最好不要讲optional用作返回值以外的其他用途。

### 56. 为所有导出的API元素编写文档注释

在每个**被导出的**类、接口、构造器、方法、域声明之前增加一个文档注释。

方法的注释：描述它和客户端之间的约定。

1. 描述方法做了什么，而不是怎么做的
2. 调用的前提条件
3. 后置条件
4. 副作用

@implSpec注释，描述方法及其子类之间的约定，为继承设计类时。

## 第九章 通用编程

### 57. 将局部变量的作用域最小化

在第一次要使用的地方进行声明。

几乎每个局部变量的声明都应该包含一个初始化表达式。

将局部变量的作用域最小化的方法是，使方法小而集中。

### 58. for-each循环优先于传统的for循环

通过完全隐藏迭代器或者索引变量，避免了混乱和出错的可能。

三种情况无法使用for-each循环：

1. 解构过滤。若果需要遍历集合，并**删除选定的元素**，就需要使用显示的迭代器。
2. 转换。如果需要遍历列表或者数组，并**取代它的部分或者全部元素值**。
3. 平行迭代。如果需要并行地遍历多个集合，需要显式地控制迭代器或者索引变量。

### 59. 了解和使用类库

使用标准类库

随机数生成器：ThreadLocalRandom。Fork Join Pool和并行Stream中使用SplittableRandom

应该把时间花在应用程序上，而不是底层的细节上。

java.lang 、 java.util 、java.io 及子包中的内容。

集合框架：Collections Framework、Stream类库

学习使用Google Guava

```xml
<dependency>
    <groupId>com.google.guava</groupId>
    <artifactId>guava</artifactId>
    <version>18.0</version>
</dependency>
```

### 60. 如果需要精确的答案，请避免使用float和double

使用BigDecimal、int、long进行货币计算

如果数值范围没有超过9位十进制数字，就可以使用int。如果不超过18位数字，就可以使用long。超过18位数字，必须使用BigDecimal。

### 61. 基本类型优于装箱基本类型

对装箱基本类型运用==操作符几乎总是错误的。

当在一项操作中混合使用基本类型和装箱基本类型时，装箱基本类型就会自动拆箱

使用装箱基本类型：

1. 作为集合中的元素、键、值。必须使用装箱基本类型。
2. 在参数化类型和方法中，必须使用装箱基本类型。ThreadLocal<Integer>.
3. 在进行反射的方法调用时。

### 62. 如果其他类型更合适，则尽量避免使用字符串

字符串不适合代替其他的值类型。

字符串不适合代替枚举类型。

字符串不适合代替聚合类型。简单地编写一个类来描述这个数据集，通常是一个私有的静态成员类。

应该避免使用字符串来表示对象，若使用不当，字符串会比其他的类型更加笨拙、更不灵活、速度更慢，也更容易出错。

### 63. 了解字符串连接的性能

为连接n个字符串而重复地使用字符串连接操作符，需要n的平方级时间。

使用StringBuilder代替String。

不要使用字符串连接操作符来合并多个字符串。

### 64. 通过接口引用对象

如果有合适的接口类型存在，那么对于参数、返回值、变量和域来说，都应该适用接口类型进行生命。

### 65. 接口优先于反射机制

如果编写的程序必须要与编译时未知的类一起工作，应该使用**反射机制类**实例化对象；而如果访问对象时，则使用编译时已知的某个**接口或者超类**。

### 66. 谨慎地使用本地方法

### 67. 谨慎地优化

优化的弊大利。

不要为了性能而牺牲合理的结构。要努力编写好的程序而不是快的程序。

要努力避免那些限制性能的设计决策。API、交互层协议、永久数据格式。

要考虑API设计决策的性能后果。为了获得好的性能而对API进行包装，这是非常不好的想法。程序把90%的时间花在10%的代码上。

不要费力去编写快速的程序——应该努力编写好的程序。在设计系统时，一定要考虑性能因素。

### 68. 遵守普遍接受的命名惯例

包或者模块

类或者接口：可实例化的类用名词或名词短语命名；不可实例化的工具类经常用复数命名；接口用Collection或者以able、ible结尾的形容词命名。

方法或者域：执行某个动作的方法用动词或动词短语命名；返回值为boolean的方法，以is开头；

常量域

局部变量域

类型参数

## 第十章 异常

### 69. 只针对异常的情况才使用异常

异常应该只用于异常的情况下，它们永远不应该用于正常的控制流。

### 70. 对可恢复的情况使用受检异常，对编程错误使用运行时异常

Java提供了三种可抛出异常：

1. 受检异常：期望调用者能够适当地恢复。方法中声明要抛出的每个受检异常，都是对API用户的一种潜在提示。
2. 运行时异常：不需要也不应该被捕获的异常。
3. 错误：不需要也不应该被捕获的异常。

用运行时异常表明编程错误。

实现的所有未受检的抛出结构都应该是RuntimeException的子类，不应该是Error子类。

异常也是一个完全意义上的对象，可以在它上面定义任意的方法。

要在受检异常上提供方法，以便协助恢复。

### 71. 避免不必要的使用受检异常

### 72. 优先使用标准异常

异常类越少，意味着内存占用越小，装载这些类的时间开销也越少。

经常重用的异常：IllegalArgumentException、 IllegalStateException（在某个对象被正确初始化之前）。

所有错误的方法调用都可以被归结为非法参数或者非法状态。

ConcurrentModificationException、UnsupportedOperationException

不要直接重用Exception、RuntimeException、Throwable、Error，对待这些类要像对待抽象类一样。

如果希望增加更多的失败—捕获信息，可以放心地子类化标准异常，但要记住异常是可序列化的，因此没有正常理由，不要自己编写异常类。

### 73. 抛出与抽象对应的异常

异常转译：更高层的实现应该捕获低层的异常，同时抛出可以按照高层抽象进行解释的异常。

低层异常处理：

1. 首先避免他们抛出异常。（参数有效性检查）
2. 让高层悄悄处理这些异常。（让高层方法的调用者与低层的问题隔离）

如果无法阻止来自低层的异常：

1. 一般使用异常转译。
2. 如果低层方法的规范碰巧可以保证“它所抛出的所有异常对于高层也是合适的”，此时才可以将异常从低层传播到高层。

异常链对高层和低层异常都提供了最佳的功能：它允许抛出适当的高层异常，同时又能捕获低层的原因进行失败分析。

### 74. 每个方法抛出的所有异常都要建立文档

始终要单独地声明受检异常，并且利用Javadoc的@throws标签，准确地记录下抛出每个异常的条件。

### 75. 在细节消息中包含失败—捕获信息

### 76. 努力使失败保持原子性

失败原子性：失败的方法调用应该使对象保持在被调用之前的状态。以便能从这种异常中恢复。

实现方法：

1. 设计一个不可变的对象
2. 在执行操作之前检查参数的有效性。
3. 调整计算处理过程的顺序，使得任何可能会失败的计算部分都在对象状态被修改之前发生。
4. 在对象的一份临时拷贝上执行操作，当操作完成后再用临时拷贝中的结果代替对象的内容。
5. 编写一段恢复代码，拦截操作过程中发生的失败，使对象回滚到操作开始前的状态。（主要用于永久性的-基于磁盘的数据结构）

错误通常是不可恢复的，因此当方法抛出AssertionError时，不需要努力去保持失败原子性。

### 77. 不要忽略异常

避免使用空的catch块生吞异常。

如果选择忽略异常，catch快中应该包含一条注释，说明为什么可以这么做，并将变量命名为ignored。

## 第十一章 并发

### 78. 同步访问共享的可变数据

synchronized(使…同步)可以保证在同一时刻，只有一个线程可以执行某一个方法，或者某一个代码块。

如果没有同步，一个线程的变化就不能被其他线程看到。

为了在线程之间进行可靠的通信，也为了互斥访问，同步是必要的。

1. 在变量的读写方法函数中添加synchronized。确保多个调用不会交叉存取
2. 使用volatile(可变的)定义变量，保证任何一个线程在读取该域的时候都将看到最近刚刚被写入的值。

增量操作符++不是原子的。

当多个线程共享不可变的数据时，每个读或者写数据的线程都必须执行同步。

如果只需要线程间交互通信，而不需要互斥，volatile修饰符是一种可以接受的同步形式。

### 79. 避免过度同步

过度同步可能导致性能降低、死锁、或者不确定行为。

为了避免死锁和数据破坏，不要从同步区域内部调用外来方法。要尽量将同步区域内部的工作量限制到最少。

### 80. executor、task和steam优先于线程

Java平台提供的java.util.concurrent。这个包包含了Executor Framework，一个灵活的基于接口的任务执行工具。

应该尽量不要编写自己的工作队列，还应该尽量不直接使用线程。

在Executor Framework中，**工作单元**和**执行机制**是分开的。工作单元（任务task）包括：Runnable和Callable。

Executor Framework还支持fork-join任务。并发的stream是在fork join池上编写的。

### 81. 并发工具优先于wait和notify

几乎没有理由再使用wait和notify了。Java5之后可以使用更高级的并发工具。

java.util.concurrent中并发工具分为三类：

1. Executor Framework
2. 并发集合Concurrent Collection：为标准接口List、Queue、Map提供高性能的并发实现，实现在内部自己管理同步。
3. 同步器 Synchronizer：是线程能够等待另一个线程的对象，允许他们协调动作。常用的同步器是Countdown Latch和Semaphore。其次是CycleBarrier和Exchange。功能最强大的是Phase。

应该优先使用ConcurrentHashMap，而不是使用Collections.synchronizedMap.可以极大地提升并发应用程度的性能。

大多数ExecutorService实现（包括ThreadPoolExecutor）都是用来一个BlokingQueue。

应该始终使用notifyAll方法。因为它会保证你唤醒所有需要被唤醒的线程，可能会唤醒其他一些线程，但并不会影响程序的正确性，这些线程醒来后，会检查他们正在等待的条件，如果发现不满足，会继续等待。

同时，java.util.concurrent提供了更高级的语言。没有理由再新代码中使用wait方法和notify方法，即使有，也是极少的。如果维护这样的代码，务必保证从while循环内部调用wait方法。

### 82. 线程安全性的文档化

必须在文档中清楚说明类所支持的线程安全性级别：

1. 不可变的 immutable，类的实例是不变的。不需要外部同步。
2. 无条件的线程安全 unconditional thread-safe。类的实例是可变的，但是有足够的内部同步，无需任何外部同步。
3. 有条件的线程安全 conditional thread-safe。
4. 非线程安全 not thread-safe.实例可变，为并发使用，客户端必须利用自己选择的外部同步包围每个方法调用。
5. 线程对立的 thread-hostile。这种类不能安全地被多个线程并发使用。这种类时因为没有考虑到并发性而产生的后果。

为了避免客户端拒绝服务攻击，应该使用一个私有锁对象来代替同步的方法(隐含一个公有可访问锁)。从而把锁对象封装在它所同步的对象中。将lock域的可访问性减到最小，应该始终声明为final。

私有锁对象模式只能用在无条件的线程安全类上。有条件的线程安全类，必须说明它的客户端程序必须获得哪把锁。

### 83. 慎用延迟初始化

除非绝对必要，否则不要延迟初始化。延迟初始化实际上降低了性能。正常初始化优于延迟初始化。

lazy initialization holder class模式：定义一个静态内部类和静态方法。延迟加载FiledType类。

```java
private static class FieldHolder {
     static final FieldType field = computeFieldValue();
}

private static FieldType getField() { return FieldHolder.field; }

private static FieldType computeFieldValue() {
     return new FieldType();
}
```

如果处于性能的考虑而需要对实例域使用延迟初始化，就使用双重检查模式（double check idiom）。

必须要使用演示初始化方法时，对于实例域，使用双重检查模式；对于静态域，则使用lazy initialization holder calss idiom。对于可以接受重复初始化的实例域，也可以考虑使用单重检查模式（single-check idiom）.

### 84. 不要依赖于线程调度器

确保可运行线程的平均数量不明显多于处理器的数量。

## 第十二章 序列化

**对象序列化Object serialization**，java框架，将对象编码成字节流（序列化），并从字节流中重新构建对象（反序列化）。

### 85. 其他方法优先于java序列化

将不被信任的流进行反序列化，可能导致远程代码执行（Remote code Execution，RCE）、拒绝服务（Denial of Service，Dos）或其他一系列攻击。

避免序列化攻击的最佳方式是永远不要反序列化任何东西。在新编写的任何新系统中都没有理由再使用Java序列化。

最前沿的跨平台结构化数据表示法是JSON和Protocol Buffers。

永远不要反序列化不被信任的数据。无法避免，就用java9中反序列化过滤功能。

### 86. 谨慎地实现Serializable接口

通常情况下，对象是利用构造器来创建的，序列化机制是一种语言之外的对象创建机制，反序列化机制是一个隐藏的构造器。

为了继承而设计的类，应该尽可能少地实现Serializable接口，用户的接口也应该尽可能少继承Serializable接口。

### 87. 考虑使用自定义的序列化形式

只有当默认的序列化形式能够合理地描述对象的逻辑状态时，才能使用默认的序列化形式；否则就要设计一个自定义的序列化形式，通过它合理描述对象的状态。

### 88.保护性地编写readObject方法

readObject方法实际上相当于另一个共有的构造器。构造器必须检查其参数的有效性，并且在必要的时候对参数进行保护性拷贝。readObject方法是一个“用字节流作为唯一参数”的构造器。这种字节流可以用来创建一个不可能的对象。这是利用普通的构造器无法创建的。


























### 

### 